<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ミニチュア世界領土変化ゲーム</title>
<style>
body { display: flex; margin: 0; height: 100vh; font-family: sans-serif; }
#controls { width: 250px; padding: 10px; background: #f0f0f0; box-sizing: border-box; overflow-y: auto; }
#canvas-container { flex: 1; position: relative; background: #ccc; touch-action: none; }
#canvas { position: absolute; top: 0; left: 0; z-index: 0; image-rendering: pixelated; }
#uploaded-image { position: absolute; top: 0; left: 0; z-index: 1; display: none; }
#ranking { margin-top: 10px; background: #fff; padding: 10px; max-height: 400px; overflow-y: auto; border: 1px solid #aaa; }
.controls input, .controls button, .controls label { display: block; margin: 5px 0; width: 100%; box-sizing: border-box; }
</style>
</head>
<body>
<div id="controls" class="controls">
    <input type="file" id="image-upload" accept="image/*">
    <button id="start-game">プレイ</button>
    <input type="color" id="territory-color" value="#ff0000">
    <input type="text" id="territory-name" placeholder="国名">
    <button id="create-territory">ランダム領土作成</button>
    <label><input type="checkbox" id="export-on-update"> 地図更新ごとに保存</label>
    <label><input type="checkbox" id="free-mode"> 自由国家設置モード</label>
    <button id="save">保存</button>
    <button id="load">読み込み</button>
    <button id="reset">リセット</button>
    <div id="ranking"><b>ランキング</b></div>
</div>
<div id="canvas-container">
    <img id="uploaded-image">
    <canvas id="canvas"></canvas>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;
const uploadedImage = document.getElementById('uploaded-image');
const rankingDiv = document.getElementById('ranking');

let territories = [];
let imageLoaded = false;
let intervalId = null;
let freeMode = false;

document.getElementById('free-mode').addEventListener('change', e => freeMode = e.target.checked);

// 画像アップロード
document.getElementById('image-upload').addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = ev => {
        uploadedImage.src = ev.target.result;
        uploadedImage.onload = () => {
            canvas.width = uploadedImage.width;
            canvas.height = uploadedImage.height;
            uploadedImage.style.display = 'block';
            imageLoaded = true;
            loadTerritories();
            drawAll();
        };
    };
    reader.readAsDataURL(file);
});

// 描画関数
function drawTriangle(x,y,r,color){ ctx.fillStyle=color; ctx.beginPath(); ctx.moveTo(x,y-r); ctx.lineTo(x-r*Math.sin(Math.PI/6),y+r*Math.cos(Math.PI/6)); ctx.lineTo(x+r*Math.sin(Math.PI/6),y+r*Math.cos(Math.PI/6)); ctx.closePath(); ctx.fill(); }
function drawDiamond(x,y,r,color){ ctx.fillStyle=color; ctx.beginPath(); ctx.moveTo(x,y-r); ctx.lineTo(x-r,y); ctx.lineTo(x,y+r); ctx.lineTo(x+r,y); ctx.closePath(); ctx.fill(); }
function drawParallelogram(x,y,w,h,color){ ctx.fillStyle=color; ctx.beginPath(); ctx.moveTo(x-w/2,y-h/2); ctx.lineTo(x+w/2,y-h/2); ctx.lineTo(x+w/2,y+h/2); ctx.lineTo(x-w/2,y+h/2); ctx.closePath(); ctx.fill(); }
function drawStar(x,y,r,color){ ctx.fillStyle=color; ctx.beginPath(); const spikes=6,len=r*1.5,step=Math.PI/spikes; for(let i=0;i<spikes*2;i++){ const angle=i*step,rad=i%2===0?r:len; const xp=x+rad*Math.cos(angle), yp=y-rad*Math.sin(angle); if(i===0) ctx.moveTo(xp,yp); else ctx.lineTo(xp,yp); } ctx.closePath(); ctx.fill(); }

function drawTerritory(t){
    switch(t.shape){
        case 'circle': ctx.fillStyle=t.color; ctx.beginPath(); ctx.arc(t.x,t.y,t.radius,0,2*Math.PI); ctx.fill(); break;
        case 'rectangle': ctx.fillStyle=t.color; ctx.fillRect(t.x-t.radius,t.y-t.radius,t.radius*2,t.radius*2); break;
        case 'triangle': drawTriangle(t.x,t.y,t.radius,t.color); break;
        case 'diamond': drawDiamond(t.x,t.y,t.radius,t.color); break;
        case 'parallelogram': drawParallelogram(t.x,t.y,t.radius,t.radius,t.color); break;
        case 'star': drawStar(t.x,t.y,t.radius,t.color); break;
    }
}

function drawAll(){
    if(!imageLoaded) return;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(uploadedImage,0,0);
    territories.forEach(drawTerritory);
}

// ランダム領土作成
document.getElementById('create-territory').addEventListener('click', ()=>{
    if(!imageLoaded) return;
    const color = document.getElementById('territory-color').value;
    const name = document.getElementById('territory-name').value || '無名';
    const shapes = ['circle','rectangle','triangle','diamond','parallelogram','star'];
    const shape = shapes[Math.floor(Math.random()*shapes.length)];
    territories.push({x:Math.random()*canvas.width,y:Math.random()*canvas.height,radius:10,color,name,shape});
    saveToLocalStorage();
    drawAll();
    updateRanking();
});

// タッチ・クリックで領土作成
function placeTerritory(clientX, clientY){
    if(!imageLoaded || !freeMode) return;
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) * (canvas.width / rect.width);
    const y = (clientY - rect.top) * (canvas.height / rect.height);
    const color = document.getElementById('territory-color').value;
    const name = document.getElementById('territory-name').value || '無名';
    const shapes = ['circle','rectangle','triangle','diamond','parallelogram','star'];
    const shape = shapes[Math.floor(Math.random()*shapes.length)];
    territories.push({x,y,radius:10,color,name,shape});
    saveToLocalStorage();
    drawAll();
    updateRanking();
}

canvas.addEventListener('click', e => placeTerritory(e.clientX,e.clientY));
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    for(let t of e.touches) placeTerritory(t.clientX, t.clientY);
}, {passive:false});

// ゲームスタート
document.getElementById('start-game').addEventListener('click', ()=>{
    if(!imageLoaded){ alert('画像をアップロードしてください'); return; }
    if(intervalId) clearInterval(intervalId);
    intervalId = setInterval(()=>{
        drawAll();
        const shuffled = territories.slice().sort(()=>0.5-Math.random());
        const expandList = shuffled.slice(0, Math.min(Math.floor(Math.random()*6+1), shuffled.length));
        expandList.forEach(t=>t.radius += Math.random()*2+6);
        if(document.getElementById('export-on-update').checked) saveToLocalStorage();
        updateRanking();
    }, Math.floor(Math.random()*2000)+1000);
});

// 保存・読み込み・リセット
document.getElementById('save').addEventListener('click', ()=>saveToLocalStorage());
document.getElementById('load').addEventListener('click', ()=>loadTerritories());
document.getElementById('reset').addEventListener('click', ()=>{
    if(confirm('本当にリセットしますか？')){ territories=[]; saveToLocalStorage(); drawAll(); updateRanking(); }
});

// LocalStorage
function saveToLocalStorage(){
    localStorage.setItem('territories', JSON.stringify(territories));
    if(imageLoaded) localStorage.setItem('savedMap', canvas.toDataURL());
}
function loadTerritories(){
    const data = localStorage.getItem('territories');
    if(data) territories = JSON.parse(data);
    drawAll();
    updateRanking();
}

// ランキング更新
function updateRanking(){
    if(!imageLoaded) return;
    const counts = {};
    territories.forEach(t=>counts[t.name]=0);
    const imgData = ctx.getImageData(0,0,canvas.width,canvas.height).data;
    for(let y=0;y<canvas.height;y++){
        for(let x=0;x<canvas.width;x++){
            const i=(y*canvas.width+x)*4;
            if(imgData[i+3]===0) continue;
            territories.forEach(t=>{
                const dx=x-t.x, dy=y-t.y, r=t.radius;
                let inside=false;
                switch(t.shape){
                    case 'circle': inside=dx*dx+dy*dy<=r*r; break;
                    case 'rectangle': inside=Math.abs(dx)<=r&&Math.abs(dy)<=r; break;
                    case 'triangle': inside=dy<=r&&dy>=-r*Math.sqrt(3)/2&&Math.abs(dx)<=r; break;
                    case 'diamond': inside=Math.abs(dx)+Math.abs(dy)<=r; break;
                    case 'parallelogram': inside=Math.abs(dx)<=r&&Math.abs(dy)<=r; break;
                    case 'star': inside=dx*dx+dy*dy<=r*r*2; break;
                }
                if(inside) counts[t.name]++;
            });
        }
    }
    const sorted = Object.entries(counts).sort((a,b)=>b[1]-a[1]);
    rankingDiv.innerHTML = "<b>ランキング</b><br>";
    sorted.forEach(([name,count],idx)=>{ if(name) rankingDiv.innerHTML += `${idx+1}. ${name}: ${count}px<br>`; });
}
</script>
</body>
</html>
