<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ミニチュア世界領土変化ゲーム</title>
<style>
    #canvas-container {
        position: relative;
        width: 100%;
        height: 100%;
    }
    #canvas {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 0;
        image-rendering: pixelated; /* アンチエイリアス無効 */
    }
    #uploaded-image {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
        display: none;
    }
    .controls {
        margin-bottom: 10px;
    }
    #ranking {
        margin-top: 10px;
        background: #f0f0f0;
        padding: 10px;
        max-height: 200px;
        overflow-y: auto;
    }
</style>
</head>
<body>
<div class="controls">
    <input type="file" id="image-upload" accept="image/*">
    <button id="start-game">プレイ</button>
    <input type="color" id="territory-color" value="#ff0000">
    <input type="text" id="territory-name" placeholder="国名">
    <button id="create-territory">領土作成</button>
    <label>
        <input type="checkbox" id="export-on-update"> 地図を更新するごとにエクスポート
    </label>
    <button id="save">保存</button>
    <button id="load">読み込み</button>
    <label>
        <input type="checkbox" id="free-mode"> 自由国家設置モード
    </label>
</div>
<div id="canvas-container">
    <img id="uploaded-image" />
    <canvas id="canvas"></canvas>
</div>
<div id="ranking"></div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false; // アンチエイリアス無効
const uploadedImage = document.getElementById('uploaded-image');
let territories = [];
let imageLoaded = false;
let intervalId;
let freeMode = false;

const rankingDiv = document.getElementById('ranking');

document.getElementById('free-mode').addEventListener('change', (e) => {
    freeMode = e.target.checked;
});

// 画像アップロードと表示
document.getElementById('image-upload').addEventListener('change', (event) => {
    const file = event.target.files[0];
    const reader = new FileReader();
    reader.onload = (e) => {
        uploadedImage.src = e.target.result;
        uploadedImage.onload = () => {
            canvas.width = uploadedImage.width;
            canvas.height = uploadedImage.height;
            uploadedImage.style.display = 'block';
            imageLoaded = true;
            loadTerritories();
            drawAll();
        };
    };
    reader.readAsDataURL(file);
});

// 領土描画関数
function drawTriangle(x, y, radius, color) {
    ctx.save();
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x, y - radius);
    ctx.lineTo(x - radius * Math.sin(Math.PI / 6), y + radius * Math.cos(Math.PI / 6));
    ctx.lineTo(x + radius * Math.sin(Math.PI / 6), y + radius * Math.cos(Math.PI / 6));
    ctx.closePath();
    ctx.fill();
    ctx.restore();
}

function drawDiamond(x, y, radius, color) {
    ctx.save();
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x, y - radius);
    ctx.lineTo(x - radius, y);
    ctx.lineTo(x, y + radius);
    ctx.lineTo(x + radius, y);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
}

function drawParallelogram(x, y, width, height, color) {
    ctx.save();
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.moveTo(x - width / 2, y - height / 2);
    ctx.lineTo(x + width / 2, y - height / 2);
    ctx.lineTo(x + width / 2, y + height / 2);
    ctx.lineTo(x - width / 2, y + height / 2);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
}

function drawStar(x, y, radius, color) {
    const spikeCount = 6;
    const spikeLength = radius * 1.5;
    const angleStep = Math.PI / spikeCount;
    ctx.save();
    ctx.fillStyle = color;
    ctx.beginPath();
    for (let i = 0; i < spikeCount * 2; i++) {
        const angle = i * angleStep;
        const r = i % 2 === 0 ? radius : spikeLength;
        const xPos = x + r * Math.cos(angle);
        const yPos = y - r * Math.sin(angle);
        if (i === 0) ctx.moveTo(xPos, yPos);
        else ctx.lineTo(xPos, yPos);
    }
    ctx.closePath();
    ctx.fill();
    ctx.restore();
}

// 領土描画共通関数
function drawTerritory(territory) {
    ctx.save();
    ctx.fillStyle = territory.color;
    if (territory.shape === 'circle') {
        ctx.beginPath();
        ctx.arc(territory.x, territory.y, territory.radius, 0, Math.PI * 2);
        ctx.fill();
    } else if (territory.shape === 'rectangle') {
        ctx.fillRect(territory.x - territory.radius, territory.y - territory.radius, territory.radius * 2, territory.radius * 2);
    } else if (territory.shape === 'triangle') {
        drawTriangle(territory.x, territory.y, territory.radius, territory.color);
    } else if (territory.shape === 'diamond') {
        drawDiamond(territory.x, territory.y, territory.radius, territory.color);
    } else if (territory.shape === 'parallelogram') {
        drawParallelogram(territory.x, territory.y, territory.radius, territory.radius, territory.color);
    } else if (territory.shape === 'star') {
        drawStar(territory.x, territory.y, territory.radius, territory.color);
    }
    ctx.restore();
}

// 全描画
function drawAll() {
    if (!imageLoaded) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(uploadedImage, 0, 0);
    territories.forEach(drawTerritory);
}

// ゲームスタート
document.getElementById('start-game').addEventListener('click', () => {
    if (!imageLoaded) { alert('画像がアップロードされていません。'); return; }
    if (intervalId) clearInterval(intervalId);

    intervalId = setInterval(() => {
        drawAll();

        const numTerritoriesToExpand = Math.floor(Math.random() * 6) + 1;
        const shuffled = territories.slice().sort(() => 0.5 - Math.random());
        const expandList = shuffled.slice(0, Math.min(numTerritoriesToExpand, shuffled.length));

        expandList.forEach((t) => {
            t.radius += Math.random() * 2 + 6;
        });

        if (document.getElementById('export-on-update').checked) saveToLocalStorage();
        updateRanking();
    }, Math.floor(Math.random() * 2000) + 1000);
});

// 領土作成（ランダム）
document.getElementById('create-territory').addEventListener('click', () => {
    if (!imageLoaded) { alert('画像がアップロードされていません。'); return; }
    const color = document.getElementById('territory-color').value;
    const name = document.getElementById('territory-name').value;
    const shapes = ['circle','rectangle','triangle','diamond','parallelogram','star'];
    const shape = shapes[Math.floor(Math.random()*shapes.length)];
    territories.push({
        x: Math.random()*canvas.width,
        y: Math.random()*canvas.height,
        radius: 10,
        color: color,
        name: name,
        shape: shape,
        angle: Math.random()*Math.PI*2
    });
    saveToLocalStorage();
    drawAll();
});

// 自由国家設置モード
canvas.addEventListener('click', (e) => {
    if (!freeMode || !imageLoaded) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const color = document.getElementById('territory-color').value;
    const name = document.getElementById('territory-name').value;
    const shapes = ['circle','rectangle','triangle','diamond','parallelogram','star'];
    const shape = shapes[Math.floor(Math.random()*shapes.length)];
    territories.push({
        x: x,
        y: y,
        radius: 10,
        color: color,
        name: name,
        shape: shape,
        angle: Math.random()*Math.PI*2
    });
    saveToLocalStorage();
    drawAll();
    updateRanking();
});

// 保存・読み込み
document.getElementById('save').addEventListener('click', saveToLocalStorage);
document.getElementById('load').addEventListener('click', () => {
    const territoriesData = localStorage.getItem('territories');
    if (territoriesData) territories = JSON.parse(territoriesData);
    drawAll();
    updateRanking();
});

// LocalStorage保存
function saveToLocalStorage() {
    const dataURL = canvas.toDataURL();
    localStorage.setItem('savedMap', dataURL);
    localStorage.setItem('territories', JSON.stringify(territories));
}

// LocalStorage読み込み
function loadTerritories() {
    const territoriesData = localStorage.getItem('territories');
    if (territoriesData) territories = JSON.parse(territoriesData);
    drawAll();
    updateRanking();
}

// ランキング計算
function updateRanking() {
    if (!imageLoaded) return;
    // ランキング計算
    const imgData = ctx.getImageData(0,0,canvas.width,canvas.height).data;
    const counts = {};
    territories.forEach(t => counts[t.name] = 0);

    for (let y=0; y<canvas.height; y++) {
        for (let x=0; x<canvas.width; x++) {
            const i = (y*canvas.width + x)*4;
            const alpha = imgData[i+3];
            if (alpha === 0) continue; // 透明ピクセルは除外
            territories.forEach(t => {
                const dx = x - t.x;
                const dy = y - t.y;
                const r = t.radius;
                let inside = false;
                switch(t.shape){
                    case 'circle': inside = dx*dx + dy*dy <= r*r; break;
                    case 'rectangle': inside = Math.abs(dx)<=r && Math.abs(dy)<=r; break;
                    case 'triangle': inside = dy <= r && dy >= -r*Math.sqrt(3)/2 && Math.abs(dx)<=r; break;
                    case 'diamond': inside = Math.abs(dx)+Math.abs(dy)<=r; break;
                    case 'parallelogram': inside = Math.abs(dx)<=r && Math.abs(dy)<=r; break;
                    case 'star': inside = dx*dx+dy*dy<=r*r*2; break;
                }
                if (inside) counts[t.name]++;
            });
        }
    }

    // 表示
    const sorted = Object.entries(counts).sort((a,b)=>b[1]-a[1]);
    rankingDiv.innerHTML = "<b>ランキング</b><br>";
    sorted.forEach(([name, count], idx) => {
        if(name) rankingDiv.innerHTML += `${idx+1}. ${name}: ${count}px<br>`;
    });
}

</script>
</body>
</html>
