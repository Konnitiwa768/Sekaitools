<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ミニチュア世界領土変化ゲーム</title>
<style>
    body {
        display: flex;
        margin: 0;
        height: 100vh;
        font-family: sans-serif;
    }
    #controls {
        width: 250px;
        padding: 10px;
        background: #f0f0f0;
        box-sizing: border-box;
        overflow-y: auto;
    }
    #canvas-container {
        flex: 1;
        position: relative;
        background: #ccc;
    }
    #canvas {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 0;
        image-rendering: pixelated;
    }
    #uploaded-image {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
        display: none;
    }
    #ranking {
        margin-top: 10px;
        background: #fff;
        padding: 10px;
        max-height: 400px;
        overflow-y: auto;
        border: 1px solid #aaa;
    }
    .controls input, .controls button, .controls label {
        display: block;
        margin: 5px 0;
        width: 100%;
        box-sizing: border-box;
    }
</style>
</head>
<body>
<div id="controls" class="controls">
    <input type="file" id="image-upload" accept="image/*">
    <button id="start-game">プレイ</button>
    <input type="color" id="territory-color" value="#ff0000">
    <input type="text" id="territory-name" placeholder="国名">
    <button id="create-territory">領土作成</button>
    <label><input type="checkbox" id="export-on-update"> 地図更新ごとに保存</label>
    <label><input type="checkbox" id="free-mode"> 自由国家設置モード</label>
    <button id="save">保存</button>
    <button id="load">読み込み</button>
    <button id="reset">リセット</button>
    <div id="ranking"><b>ランキング</b></div>
</div>
<div id="canvas-container">
    <img id="uploaded-image" />
    <canvas id="canvas"></canvas>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;
const uploadedImage = document.getElementById('uploaded-image');
const rankingDiv = document.getElementById('ranking');

let territories = [];
let imageLoaded = false;
let intervalId;
let freeMode = false;

document.getElementById('free-mode').addEventListener('change', (e)=>{ freeMode=e.target.checked; });

// 画像アップロード
document.getElementById('image-upload').addEventListener('change',(e)=>{
    const file = e.target.files[0];
    const reader = new FileReader();
    reader.onload = (ev)=>{
        uploadedImage.src = ev.target.result;
        uploadedImage.onload = ()=>{
            canvas.width = uploadedImage.width;
            canvas.height = uploadedImage.height;
            uploadedImage.style.display='block';
            imageLoaded=true;
            loadTerritories();
            drawAll();
        };
    };
    reader.readAsDataURL(file);
});

// 描画関数
function drawTriangle(x,y,r,color){
    ctx.save();
    ctx.fillStyle=color;
    ctx.beginPath();
    ctx.moveTo(x, y - r);
    ctx.lineTo(x - r * Math.sin(Math.PI/6), y + r * Math.cos(Math.PI/6));
    ctx.lineTo(x + r * Math.sin(Math.PI/6), y + r * Math.cos(Math.PI/6));
    ctx.closePath();
    ctx.fill();
    ctx.restore();
}
function drawDiamond(x,y,r,color){
    ctx.save();
    ctx.fillStyle=color;
    ctx.beginPath();
    ctx.moveTo(x, y - r);
    ctx.lineTo(x - r, y);
    ctx.lineTo(x, y + r);
    ctx.lineTo(x + r, y);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
}
function drawParallelogram(x,y,w,h,color){
    ctx.save();
    ctx.fillStyle=color;
    ctx.beginPath();
    ctx.moveTo(x-w/2, y-h/2);
    ctx.lineTo(x+w/2, y-h/2);
    ctx.lineTo(x+w/2, y+h/2);
    ctx.lineTo(x-w/2, y+h/2);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
}
function drawStar(x,y,r,color){
    const spikeCount=6, spikeLength=r*1.5, step=Math.PI/spikeCount;
    ctx.save(); ctx.fillStyle=color; ctx.beginPath();
    for(let i=0;i<spikeCount*2;i++){
        const angle=i*step;
        const rad=i%2===0?r:spikeLength;
        const xp=x+rad*Math.cos(angle);
        const yp=y-rad*Math.sin(angle);
        if(i===0) ctx.moveTo(xp,yp); else ctx.lineTo(xp,yp);
    }
    ctx.closePath(); ctx.fill(); ctx.restore();
}
function drawTerritory(t){
    ctx.save(); ctx.fillStyle=t.color;
    if(t.shape==='circle'){ ctx.beginPath(); ctx.arc(t.x,t.y,t.radius,0,Math.PI*2); ctx.fill(); }
    else if(t.shape==='rectangle'){ ctx.fillRect(t.x-t.radius,t.y-t.radius,t.radius*2,t.radius*2);}
    else if(t.shape==='triangle'){ drawTriangle(t.x,t.y,t.radius,t.color);}
    else if(t.shape==='diamond'){ drawDiamond(t.x,t.y,t.radius,t.color);}
    else if(t.shape==='parallelogram'){ drawParallelogram(t.x,t.y,t.radius,t.radius,t.color);}
    else if(t.shape==='star'){ drawStar(t.x,t.y,t.radius,t.color);}
    ctx.restore();
}
function drawAll(){
    if(!imageLoaded) return;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(uploadedImage,0,0);
    territories.forEach(drawTerritory);
}

// ゲームスタート
document.getElementById('start-game').addEventListener('click',()=>{
    if(!imageLoaded){ alert('画像がアップロードされていません。'); return;}
    if(intervalId) clearInterval(intervalId);
    intervalId=setInterval(()=>{
        drawAll();
        const shuffled=territories.slice().sort(()=>0.5-Math.random());
        const expandList=shuffled.slice(0, Math.min(Math.floor(Math.random()*6+1),shuffled.length));
        expandList.forEach(t=>{ t.radius += Math.random()*2+6; });
        if(document.getElementById('export-on-update').checked) saveToLocalStorage();
        updateRanking();
    }, Math.floor(Math.random()*2000)+1000);
});

// ランダム領土作成
document.getElementById('create-territory').addEventListener('click',()=>{
    if(!imageLoaded){ alert('画像がアップロードされていません.'); return;}
    const color=document.getElementById('territory-color').value;
    const name=document.getElementById('territory-name').value;
    const shapes=['circle','rectangle','triangle','diamond','parallelogram','star'];
    const shape=shapes[Math.floor(Math.random()*shapes.length)];
    territories.push({x:Math.random()*canvas.width,y:Math.random()*canvas.height,radius:10,color,name,shape,angle:Math.random()*Math.PI*2});
    saveToLocalStorage();
    drawAll();
    updateRanking();
});

// 自由国家設置モード
canvas.addEventListener('click',(e)=>{
    if(!freeMode || !imageLoaded) return;
    const rect=canvas.getBoundingClientRect();
    const x=e.clientX-rect.left, y=e.clientY-rect.top;
    const color=document.getElementById('territory-color').value;
    const name=document.getElementById('territory-name').value;
    const shapes=['circle','rectangle','triangle','diamond','parallelogram','star'];
    const shape=shapes[Math.floor(Math.random()*shapes.length)];
    territories.push({x,y,radius:10,color,name,shape,angle:Math.random()*Math.PI*2});
    saveToLocalStorage();
    drawAll();
    updateRanking();
});

// 保存・読み込み
document.getElementById('save').addEventListener('click',saveToLocalStorage);
document.getElementById('load').addEventListener('click',()=>{
    const data=localStorage.getItem('territories');
    if(data) territories=JSON.parse(data);
    drawAll();
    updateRanking();
});

// リセット
document.getElementById('reset').addEventListener('click',()=>{
    if(confirm('本当にリセットしますか？すべての領土データが消えます。')){
        territories=[];
        saveToLocalStorage();
        drawAll();
        updateRanking();
    }
});

// LocalStorage保存
function saveToLocalStorage(){
    const dataURL=canvas.toDataURL();
    localStorage.setItem('savedMap',dataURL);
    localStorage.setItem('territories',JSON.stringify(territories));
}

// LocalStorage読み込み
function loadTerritories(){
    const data=localStorage.getItem('territories');
    if(data) territories=JSON.parse(data);
    drawAll();
    updateRanking();
}

// ランキング計算
function updateRanking(){
    if(!imageLoaded) return;
    const imgData=ctx.getImageData(0,0,canvas.width,canvas.height).data;
    const counts={};
    territories.forEach(t=>counts[t.name]=0);

    for(let y=0;y<canvas.height;y++){
        for(let x=0;x<canvas.width;x++){
            const i=(y*canvas.width+x)*4;
            if(imgData[i+3]===0) continue;
            territories.forEach(t=>{
                const dx=x-t.x, dy=y-t.y, r=t.radius;
                let inside=false;
                switch(t.shape){
                    case 'circle': inside=dx*dx+dy*dy<=r*r; break;
                    case 'rectangle': inside=Math.abs(dx)<=r&&Math.abs(dy)<=r; break;
                    case 'triangle': inside=dy<=r&&dy>=-r*Math.sqrt(3)/2&&Math.abs(dx)<=r; break;
                    case 'diamond': inside=Math.abs(dx)+Math.abs(dy)<=r; break;
                    case 'parallelogram': inside=Math.abs(dx)<=r&&Math.abs(dy)<=r; break;
                    case 'star': inside=dx*dx+dy*dy<=r*r*2; break;
                }
                if(inside) counts[t.name]++;
            });
        }
    }

    const sorted=Object.entries(counts).sort((a,b)=>b[1]-a[1]);
    rankingDiv.innerHTML="<b>ランキング</b><br>";
    sorted.forEach(([name,count],idx)=>{ if(name) rankingDiv.innerHTML+=`${idx+1}. ${name}: ${count}px<br>`; });
}
</script>
</body>
</html>
